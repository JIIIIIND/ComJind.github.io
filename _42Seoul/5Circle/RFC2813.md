---
title: "RFC 2813"
excerpt: "IRC Server Protocol"
date: 2021-03-01 14:10:05 +0900
categories: 42Seoul
---

## Introduction

이 문서는 IRC 서버를 구현하는 사람들을 위한 것이지만 IRC 서비스를 구현하는 모든 사람들에게도 유용할 것 입니다.

서버는 "IRC:아키텍처"에 정의 된 실시간 회의에 필요한 세 가지 기본 서비스인 클라이언트 로케이터(클라이언트 프로토콜을 통함), 메시지 릴레이(여기서 정의함) 및 채널 호스팅 및 관리(채널 관리 프로토콜을 통함)를 제공합니다.

## Global Database

IRC 프로토콜은 상당히 분산 된 모델을 정의하지만 각 서버는 전체 IRC 네트워크에 대한 "글로벌 상태 데이터베이스"를 유지합니다. 이론적으로 이 데이터 베이스는 모든 서버에서 동일합니다.

### Servers

서버는 최대 길이가 63자인 이름으로 고유하게 식별됩니다. 서버 이름에 사용될 수 있는 것과 사용되지 않을 수 있는 것에 대해서는 프로토콜 문법 규칙(섹션 3.3.1)을 참조하십시오

각 서버는 일반적으로 다른 모든 서버에 의해 알려져 있지만 "호스트 마스크"를 정의하여 이름에 따라 서버를 그룹화 할 수 있습니다.
호스트 마스크 영역 내에서 모든 서버는 호스트 마스크와 일치하는 이름을 가지며 호스트 마스크와 일치하는 이름을 가진 다른 서버는 호스트 마스크 영역 외부의 IRC 네트워크에 연결되지 않아야 합니다.
영역 외부에 있는 서버는 영역 내부에 있는 개별 서버에 대한 지식이 없으며 대신 이름에 대한 호스트 마스크가 있는 가상 서버가 제공됩니다.

### Clients

각 클라이언트에 대해 모든 서버는 다음과 같은 정보를 가져야 합니다.
- 네트워크 전체 고유 식별자
- 클라이언트가 연결된 서버

- Users
	- 최대 길이가 9자인 고유한 별명으로 구별 됨
	- 프로토콜 문법 규칙(섹션 3.3.1)을 참조
	- 모든 서버에는 모든 사용자에 대한 다음 정보가 있어야 함
		- 사용자가 실행중인 호스트의 이름
		- 해당 호스트의 사용자 이름
		- 클라이언트가 연결된 서버
- Services
	- 별명과 서버 이름으로 구성된 서비스 이름으로 다른 서비스와 구별 됨
	- 닉네임의 최대 길이는 9자
	- 프로토콜 문법 규칙(섹션 3.3.1) 참조
	- 서비스 이름을 구성하는 데 사용되는 서버 이름은 서비스가 연결된 서버의 이름
	- 모든 서버는 서비스 유형을 알아야 함
	- 서비스와 사용자는 서버에 대해 동일한 유형의 액세스 권한을 가지고 있지 않음
	- 서비스는 서버가 유지하는 전역 상태 정보의 일부 또는 전체를 요청할 수 있지만 제한된 명령 집합을 사용할 수 있으며 채널에 참여할 수 없음(자세한 내용은 RFC 2812를 참조)
	- 서비스는 섹션 5.8에 설명 된 Flood Control 메커니즘의 적용을 받지 않음

### Channels

서비스와 마찬가지로 채널에는 범위가 있으며 반드시 모든 서버에 알려지지는 않습니다.
채널 존재가 서버에 알려지면 서버는 채널 멤버와 채널 모드를 추적해야 합니다.(Keep track)

## The IRC Server Specification

### Overview

여기에 설명 된 프로토콜은 서버 간 연결에 사용하기 위한 것입니다.
클라이언트 대 서버 연결에 대해서는 IRC 클라이언트 프로토콜 사양을 참조하십시오
클라이언트 연결(신뢰할 수 없는 것으로 간주)에는 서버 연결보다 더 많은 제한이 있습니다.

### Character codes

프로토콜은 8비트를 구성하는 8비트로 구성된 코드 세트를 기반으로 합니다.
각 메시지는 이러한 8진수로 구성 될 수 있습니다.
일부 옥텟 값은 메시지 구분 기호로 작동하는 제어 코드에 사용됩니다.
8비트 프로토콜에 관계없이 구분 기호와 키워드는 프로토콜이 대부분 US-ASCII 터미널 및 텔넷 연결에서 사용하도록 되어 있습니다.
IRC의 스칸디나비아 기원으로 인해 ```{} | ^``` 문자는 각각 ```[] \ ~```문자의 소문자로 간주됩니다.
이것은 두 개의 별명 또는 채널 이름의 동등성을 판별 할 때 중요한 문제입니다.

### Messages

서버와 클라이언트는 응답을 생성하거나 생성하지 않는 메시지를 서로 보냅니다.
서버는 대부분 클라이언트에 대한 라우팅 작업을 수행하므로 서버 간의 대부분의 통신은 응답을 생성하지 않습니다.
각 IRC 메시지는 접두어(OPTIONAL), 명령, 명령 매개변수(최대 15개)의 세 가지 주요 부분으로 구성 될 수 있습니다.
접두사, 명령 및 모든 매개변수는 각각 하나의 ASCII 공백 문자로 구분됩니다.

- 접두사
	- 콜론 문자로 표시
	- 메시지 자체의 첫 번째 문자
	- 콜론과 접두사 사이에는 공백 없음
	- 서버에서 메시지의 실제 출처를 나타내는데 사용
	- 접두사가 메시지에서 누락 된 경우 해당 접두사가 수신 된 연결에서 시작된 것으로 간주
	- 클라이언트는 자신에게서 메시지를 보낼 때 접두사를 사용하지 않음
		- 유일하게 허용된 접두어의 사용은 클라이언트와 관련된 닉네임 등록
	- 서버는 메시지를 수신할 때(최종적으로 가정되는) 접두사를 사용해 소스를 식별해야 함
	- 서버의 내부 데이터베이스에서 접두어를 찾을 수 없는 경우 반드시 버려야 하며 접두사가 서버에서 온 것으로 표시되면 메시지를 수신 한 링크를 삭제해야 함
		- 네트워크의 무결성을 유지하고 향후 문제를 방지하기 위함
	- 다른 오류는 서버의 내부 데이터베이스에 있는 접두사가 다른 소스(일반적으로 메시지가 도착한 링크와 다른 링크에서 등록 된 소스)를 식별하는 것
		- 메시지가 서버 링크에서 수신되고 접두사가 클라이언트를 식별하는 경우 클라이언트에 대해 KILL 메시지가 발행되어 모든 서버로 전송
		- 다른 경우에 메시지가 도착한 링크는 서버와 클라이언트에 대해 제거되어야 함
		- 모든 경우에서 메시지는 제거되어야 함
- 명령
	- 유효한 IRC 명령이거나 ASCII 텍스트로 표시되는 세 자리 숫자
	- IRC 메시지는 항상 CR-LF 쌍으로 끝나는 문자 줄이며, 이러한 메시지는 후행 CR-LF를 포함한 모든 문자를 계산하여 길이가 512자를 초과하지 않음
		- 명령 및 해당 매개 변수에 허용되는 최대 문자 수는 510자
	- 연속 메시지 라인에 대한 규정은 없음
	- 자세한 내용은 섹션 5 참조

- Message format in Augmented BNF
	- 프로토콜 메시지는 연속적인 옥텟 스트림에서 추출되어야 함
		- 현재 해결책은 메시지 구분 기호로 CR-LF를 지정하는 것
		- 빈 메시지는 자동으로 무시되므로 추가 문제없이 메시지 사이에 CR-LF 시퀀스를 사용할 수 있음
	- 추출 된 메시지는 구성 요소 ```<prefix>, <command>, <params>```로 구문 분석됨
		- 이에 대한 BNF 구문은 RFC-2812 참조
	- 확장된 접두사(["!"사용자"@"HOST])는 서버 간 통신에 사용해서는 안되며 클라이언트에게 추가적인 쿼리가 필요 없는 메시지의 출처에 대한 보다 유용한 정보를 제공하기 위해 서버 간 메시지에만 사용됨

### Numric replies

서버로 전송되는 대부분의 메시지는 일종의 응답을 생성합니다.
가장 일반적인 응답은 오류 및 일반 응답 모두에 사용되는 숫자 응답입니다.
숫자 응답은 발신자 접두사, 3자리 숫자 및 응답 대상으로 구성된 하나의 메시지로 전송되어야 합니다.
클라이언트로부터의 숫자 응답은 허용되지 않습니다.
서버에서 수신 한 이러한 메시지는 자동으로 삭제됩니다.
다른 모든 측면에서 숫자 응답은 키워드가 문자열이 아닌 3자리 숫자로 구성된다는 점을 제외하면 일반 메시지와 같습니다.
다른 응답 목적은 RFC 2812에 제공됩니다.

## Message Details

IRC 서버와 클라이언트가 인식하는 모든 메시지는 IRC 클라이언트 프로토콜 사양에 설명되어 있습니다.
ERR_NOSUCHSERVER 응답이 리턴되면 메시지 대상을 찾을 수 없음을 의미합니다.
서버는 해당 명령에 대해 이 오류 후에 다른 응답을 보내면 안됩니다.
클라이언트가 연결된 서버는 전체 메시지를 구문 분석하여 적절한 오류를 반환해야 합니다.
메시지를 구문 분석하는 동안 서버에서 치명적인 오류가 발생하면 오류가 클라이언트로 다시 전송되고 구문 분석이 종료되어야 합니다.

치명적 오류는 다음과 같습니다.
- 잘못된 명령
- 서버에서 알 수 없는 대상(서버, 클라이언트, 채널 이름이 이 범주에 해당함)
- 매개 변수가 충분하지 않음
- 잘못된 권한

전체 매개 변수 세트가 공개되면 각 매개 변수의 유효성을 확인하고 적절한 응답을 클라이언트로 다시 보내야 합니다.
항목 구분 기호로 쉼표를 사용하는 매개 변수 목록을 사용하는 메시지의 경우 각 항목에 대해 응답을 보내야 합니다.
아래 예에서 일부 메시지는 전체 형식을 사용하여 나타납니다.

```
:Name COMMAND parameter list
```

이러한 예는 서버간에 전송되는 "Name"의 메시지를 나타내며, 원격 서버에서 메시지의 원래 보낸 사람 이름을 포함해야 올바른 경로를 따라 답장을 보낼 수 있습니다.
클라이언트와 서버 간 통신에 대한 메시지 세부 사항은 "IRC 클라이언트 프로토콜"에 설명되어 있습니다.
다음 페이지의 일부 섹션은 이러한 메시지 중 일부에 적용되며 서버 간 통신 또는 서버 구현에만 관련된 메시지 사양에 대한 추가 사항입니다.
여기에 소개 된 메시지는 서버 간 통신에만 사용됩니다.

### Connection Registration

여기에 설명 된 명령은 다른 IRC 서버와의 연결을 등록하는 데 사용됩니다.

- Password message
	- Command
		- PASS
	- Parameter
		- ```<password> <version> <flags> [<options>]```
	- 연결 암호를 설정하는 데 사용됨
	- 연결 등록을 시도하기 전에 암호를 설정해야 함
		- SERVER 명령보다 먼저 PASS 명령을 보내야 함을 의미함
	- 하나의 연결에는 하나의 PASS 명령 만 허용
	- 클라이언트로부터 수신 된 경우 마지막 세 개의 매개 변수는 무시되어야 함
		- 서버에서 받은 경우에만 관련 있음
	- ```<version>```
		- 매개 변수는 최소 4, 최대 14의 문자열
		- 처음 4개는 숫자여야 하며 메시지를 발행하는 서버가 알고 있는 프로토콜 버전을 나타내야 함
		- 이 문서에서 설명하는 프로토콜은 "0210"으로 인코딩 된 버전 2.10
		- 구현에 따라 다르며 소프트웨어 버전 번호를 설명해야 함
		- 나머지 OPTIONAL 문자는 구현에 따라 다르며 소프트웨어 버전 번호를 설명해야 함
	- ```<flags>```
		- 최대 100자의 문자열
		- 문자 "|"(%x7C)로 구분 된 두 개의 하위 문자열로 구성
		- 존재하는 경우 첫 번째 하위 문자열은 구현의 이름이어야 함
		- 참조 구현은 "IRC"를 사용
		- 식별자가 필요한 다른 구현이 작성된 경우 해당 식별자는 RFC 게시를 통해 등록되어야 함
		- 두 번째 하위 문자열은 구현에 따라 다름
		- 두 부분 문자열 모두 선택 사항이지만 문자 "|"는 필수이며, 어느 부분 문자열에도 나타나지 않아야 함
	- ```<options>```
		- 링크 옵션에 사용됨
		- 프로토콜에 의해 정의 된 유일한 옵션은 링크 압축(문자 'Z')과 남용 방지 플래그(문자 'P')
		- 이러한 옵션에 대한 자세한 내용은 섹션 5.3.1.1(Compressed server to server links) 및 5.3.1.2(Anti abuse protections) 참조
	- Numeric Replies
		- ERR_NEEDMOREPARAMS
		- ERR_ALREADYREGISTRED
	- Example
		- ```PASS moresecretpassword 0210010000 IRC|aBgH$ Z```
- Server message
	- Command
		- SERVER
	- Parameter
		- ```<servername> <hopcount> <token> <info>```
	- 새 서버를 등록하는 데 사용
	- 새로운 연결은 피어에 대한 서버로 자신을 소개
	- 이 메시지는 전체 네트워크를 통해 서버 데이터를 전달하는데도 사용됨
	- 새 서버가 네트워크에 연결되면 그에 대한 정보가 전체 네트워크에 브로드 캐스트되어야 함
	- ```<info>```
		- 매개 변수에는 공백 문자가 포함될 수 있음
	- ```<hopcount>```
		- 각 서버가 얼마나 멀리 떨어져 있는지에 대한 내부 정보를 모든 서버에 제공하는 데 사용
		- 로컬 피어의 값은 0이고 전달 된 각 서버는 값을 증가시킴
		- 전체 서버 목록을 사용하면 전체 서버 트리의 맵을 구성할 수 있지만 호스트 마스크는 이를 수행하지 못하게 함
	- ```<token>```
		- 서버에서 식별자로 사용하는 부호 없는 숫자
		- 이후 서버간에 전송되는 NICK 및 SERVICE 메시지에서 서버를 참조하는 데 사용
		- 서버 토큰은 사용되는 지점 간 피어링에만 의미가 있으며 해당 연결에 대해 고유해야 함
		- 글로벌 하지 않음
		- SERVER 메시지는 다음 상황에서 수락됩니다.
			- 아직 등록되지 않았고 서버로 등록을 시도 중인 연결
			- 다른 서버에 대한 기존 연결
				- 이 경우 SERVER 메시지는 해당 서버 뒤에 새 서버를 도입
		- SERVER 명령을 수신 할 때 발생하는 대부분의 오류는 대상 호스트(대상 SERVER)에서 연결을 종료함
		- 이러한 이벤트의 심각도 때문에 오류 응답은 일반적으로 숫자가 아닌 "ERROR" 명령을 사용하여 전송됨
		- SERVER 메시지가 구문 분석되고 수신 서버에 이미 알려진 서버를 도입하려고 시도하는 경우 해당 메시지가 도착한 연결을 닫아야 함(올바른 절차에 따라)
			- 서버에 대한 중복 경로가 발생하여 IRC 트리의 비순환적 특성이 깨짐
			- 일부 조건에서는 이미 알려진 서버가 등록 되는 서버 대신 닫힐 수 있음
			- 해당 문제는 프로토콜 내에서 수정할 수 없으며 일반적으로 사람의 개입이 필요
			- 이러한 유형의 문제는 IRC 네트워크의 일부가 매우 쉽게 분리되어 두 서버 중 하나가 각 파티션에 연결되어 두 부분이 통합되는 것을 불가능하게 만들 수 있음
	- Numeric Replies
		- ERR_ALREADYREGISTRED
	- Example
		- ```SERVER test.oulu.fi 1 1 :Experimental server```
			- 새로운 서버인 test.oulu.fi가 자신을 소개하고 등록을 시도함
		- ```:tolsun.oulu.fi SERVER csd.bu.edu 5 34 :BU Central Server```
			- 서버 tolusun.oulu.fi는 5홉 떨어진 csd.bu.edu의 업 링크
			- 토큰 "34"는 csd.bu.edu에 연결된 새로운 사용자나 서비스를 소개 할 때 tolsun.oulu.fi에 의해 사용됨
- Nick
	- Command
		- NICK
	- Parameter
		- ```<nickname> <hopcount> <username> <host> <servertoken> <umode> <realname>```
	- 이 형식의 NICK 메시지는 사용자 연결에서 허용하지 않아야 함
	- 그러나 IRC 네트워크에 가입 한 새로운 사용자를 다른 서버에 알리기 위해 NICK/USER 쌍 대신 사용
	- 이 메시지는 실제로 NICK, USER 및 MODE의 세 가지 개별 메시지의 조합
	- ```<hopcount>```
		- 사용자가 홈 서버에서 얼마나 멀리 떨어져 있는지 표시하기 위해 서버에서 사용됨
		- 로컬 연결의 hopcount는 0
		- hopcount 값은 전달 된 각 서버에서 증가
	- ```<servertoken>```
		- USER의 ```<servername>``` 매개변수를 대체함(자세한 정보는 섹션 4.1.2(Server message) 참조)
	- Example
		- ```NICK syrk 5 kalt millennium.stealth.net 34 +i :Christophe Kalt```
			- 호스트 "millennium.stealth.net"에서 서버 "34"(이전 예에서는 "csd.bu.edu")로 연결된 별명 "syrk", 사용자 이름 "kalt"를 가진 새로운 사용자
		- ```:krys NICK syrk```
			- "IRC 클라이언트 프로토콜"에 정의되어 있고 서버간에 사용되는 다른 형식의 NICK 메시지 :kyrs가 그의 별명을 syrk로 변경
- Service message
	- Command
		- SERVICE
	- Parameter
		- ```<servicename> <servertoken> <distribution> <type> <hopcount> <info>```
	- 새 서비스를 도입하는데 사용
	- 이 형태의 SERVICE 메시지는 클라이언트(등록되지 않았거나 등록 된) 연결에서 허용되지 않아야 함
	- IRC 네트워크에 가입하는 새로운 서비스를 다른 서버에 알리기 위해 서버간에는 사용해야 함
	- ```<servertoken>```
		- 서비스가 연결된 서버를 식별하는 데 사용
		- 자세한 내용은 섹션 4.1.2(Server message) 참조
	- ```<hopcount>```
		- 서비스가 홈 서버에서 얼마나 멀리 떨어져 있는지 표시하기 위해 서버에서 사용
		- 로컬 연결의 hopcount는 0
		- 전달 된 각 서버에서 증가함
	- ```<distribution>```
		- 서비스의 가시성을 지정하는 데 사용
		- 배포판과 일치하는 이름을 가진 서버에만 알려질 수 있음
		- 일치하는 서버가 서비스에 대한 정보를 가지려면 해당 서버와 서비스가 연결된 서버 사이의 네트워크 경로는 이름이 모두 마스크와 일치하는 서버로 구성되어야 함
		- 제한이 없는 경우 일반적으로 "*"가 사용됨
	- ```<type>```
		- 향후 사용을 위해 예약됨
	- Numeric Replies
		- ERR_ALREADYREGISTRED
		- ERR_NEEDMOREPARAMS
		- ERR_ERRONEUSNICKNAME
		- RPL_YOURESERVICE
		- RPL_YOURHOST
		- RPL_MYINFO
	- Example
		- ```SERVICE dict@irc.fr 9 .fr 0 1```
			- 서버 "9"에 등록 된 프랑스어 사전 r" 이 다른 서버에 공지됨
			- 이 서비스 이름이 ".fr"과 일치하는 서버에서만 사용할 수 있음
- Quit
	- Command
		- QUIT
	- Parameter
		- ```[<Quit Message>]```
	- 클라이언트 세션은 종료 메시지와 함께 종료
	- 서버는 QUIT 메시지를 보내는 클라이언트와의 연결을 닫아야 함
	- "Quit Message"가 제공되면 기본 메시지, 별명 또는 서비스 이름 대신 전송
	- "netsplit"(섹션 4.1.6(Server quit message) 참조)이 발생하면 "Quit Message"는 공백으로 구분 된 두 서버의 이름으로 구성됨
		- 첫 번째 이름은 아직 연결되어 있는 서버의 이름
		- 두 번째 이름은 끊어진 서버의 이름이거나 나가는 클라이언트가 연결된 서버의 이름
		- ```<Quit Message> = ":" servername SPACE servername```
			- "Quit Message"는 "netsplits"에 대해 특별한 의미를 갖기 때문에 서버는 클라이언트가 위에 설명 된 형식으로 ```<Quit Message>```를 사용하는 것을 허용해서는 안됨
	- 다른 이유로 인해 클라이언트가 QUIT 명령을 실행하지 않고 클라이언트 연결이 닫히면(클라이언트가 죽고 소켓에서 EOF가 발생하는 경우) 서버는 종료 메시지를 다음의 특성을 반영하는 일종의 메시지로 채워야 함
		- 일반적으로 시스템 특정 오류를 보고하여 수행됨
	- Numeric Replies
		- None
	- Example
		- ```:WiZ QUIT :Gone to have lunch```
			- 선호하는 형식으로 작성
- Server quit message
	- Command
		- SQUIT
	- Parameter
		- ```<server> <comment>```
	- SQUIT에는 두 가지 용도가 있음
		- 운영자가 로컬 또는 원격 서버 링크를 끊을 수 있도록 함
			- 결국 서버에서 원격 서버 링크를 끊는 데 사용됨
		- 네트워크 분할이 발생할 때 다른 서버에 알리는데 필요
			- 다른 서버에 종료 또는 중지 된 서버에 대해 알리는 것
			- 서버가 다른 서버와의 연결을 끊으려면 다른 서버의 이름을 서버 매개 변수로 사용하여 다른 서버에 SQUIT 메시지를 보내야 함
			- 그러면 종료 서버와의 연결이 닫힘
	- ```<comment>```
		- 오류 또는 유사한 메시지를 표시해야 하는 서버로 채워짐
	- 닫히는 연결의 양쪽에 있는 두 서버 모두 해당 링크 뒤에 있는 것으로 간주되는 다른 모든 서버에 대해 SQUIT 메시지를 보내야 함
	- 마찬가지로 QUIT 메시지는 해당 종료 링크 뒤에 있는 모든 클라이언트를 대신하여 여전히 연결된 다른 서버로 전송 될 수 있음
	- 분할로 인해 회원을 잃은 채널의 모든 채널 회원은 반드시 QUIT 메시지를 보내야 함
	- 채널 구성원에게 보내는 메시지는 각 클라이언트의 로컬 서버에서 생성됨
	- 서버 연결이 조기에 종료된 경우(링크의 다른 쪽 끝에 있는 서버가 중단 된 경우) 연결이 끊어진 것을 감지 한 서버는 나머지 네트워크에 연결이 닫혔음을 알리고 주석 필드에 적당한 무언가를 채워야 함
	- SQUIT 메시지의 결과로 클라이언트가 제거되면 서버는 향후 별칭 충돌을 방지하기 위해 일시적으로 사용할 수 없는 별칭 목록에 별칭을 추가해야 함
		- 이 절차에 대한 자세한 내용은 섹션 5.7(Tracking recently used nickname)을 참조
	- Numeric replies
		- ERR_NOPRIVILEGES
		- ERR_NOSUCHSERVER
		- ERR_NEEDMOREPARAMS
	- Example
		- ```SQUIT tolsun.oulu.fi :Bad Link ?```
			- 서버 링크 tolson.oulu.fi가 "Bad Link"로 인해 종료되었음
		- ```:Trillian SQUIT cm22.eng.umd.edu :Server out of control```
			- Trillian에서 "Server out of control"로 인해 "cm22.eng.umd.edu"를 인터넷에서 분리하라는 메시지가 표시됨

### Channel operations

- Join message
- Njoin message
- Mode message

## Implementation details

### Connection 'Liveness'

### Accepting a client to server connection

- Users
- Services

### Establishing a server-server connection

- Link options
	- Compressed server to server link
	- Anti abuse protections
- State information exchange when connecting

### Terminating server-client connections

### Terminating server-server connections

### Tracking nickname changes

### Tracking recently used nicknames

### Flood control of clients

### Non-blocking lookups

- Hostname (DNS) lookups
- Username (Ident) lookups

## Current problems

### Scalability

### Labels

- Nicknames
- Channels
- Servers

### Algorithms

## Security Considerations

### Authentication

### Integrity

## Current support and availability

## Acknowledgements

## Reference